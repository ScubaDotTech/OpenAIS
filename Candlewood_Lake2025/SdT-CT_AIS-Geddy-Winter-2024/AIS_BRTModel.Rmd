Geddy Lucier
Testing out a BRT Model for Candlewood Lake Future Ecological Data 
3/11/2024


Preamble
```{r}
#install.packages("gbm")
#install.packages("dismo")

library(gbm)
library(dismo)
library(dplyr)
library(tidyverse)

eco <- read.csv("/Users/geddylucier/Documents/GitHub/LakeCandlewood/Candlewood_Lake2025/SdT-CT_AIS-Geddy-Winter-2024/eco_data.csv")

species <- read.csv("/Users/geddylucier/Documents/GitHub/LakeCandlewood/Candlewood_Lake2025/SdT-CT_AIS-Geddy-Winter-2024/species_data.csv")

substrate <- read.csv("/Users/geddylucier/Documents/GitHub/LakeCandlewood/Candlewood_Lake2025/SdT-CT_AIS-Geddy-Winter-2024/geo_data.csv")
?write_csv


```
Column Substrate Recoding and Cleaning
```{r}
# #bind substrate from merged_transect (species_pop_agg doc)
# ?left_join
# # 
# eco <- left_join(eco, substrate, by = "year")
# # 
# write_csv(eco, file = ("/Users/geddylucier/Documents/GitHub/LakeCandlewood/Candlewood_Lake2025/SdT-CT_AIS-Geddy-Winter-2024/eco_data.csv"))

#write_csv(substrate, file = ("/Users/geddylucier/Documents/GitHub/LakeCandlewood/Candlewood_Lake2025/SdT-CT_AIS-Geddy-Winter-2024/geo_data.csv"))




eco_base <- bind_cols(species, substrate)  # Drop duplicate 'year'
eco_base <- eco_base %>% 
  select(-year...56)  %>%
  rename("year" = "year...5"  )


eco_base <- eco_base %>%
  mutate(substrate = str_to_lower(substrate)) %>%  # Convert to lowercase
  mutate(substrate = str_replace_all(substrate, "sitt|slt|sit|sill|silt", "silt")) %>%  # Standardize "silt"
  mutate(substrate = str_replace_all(substrate, "sard", "sand")) %>%  # Fix "sard" to "sand"
  mutate(substrate = str_replace_all(substrate, "muck\\.", "muck")) %>%  # Remove extra dot in "muck."
  mutate(substrate = str_to_title(substrate))  # Capitalize first letter



eco_base <- eco_base %>%
  mutate(substrate.code = case_when( # give each substrate a numerical code based on hardness and density
    substrate == "Muck" ~ 1,
        substrate == "Organic" ~ 2,
            substrate == "Peat" ~ 3,
             substrate == "Silt" ~ 4,
                 substrate == "Sand" ~ 5,
                     substrate == "Gravel" ~ 6,
                         substrate == "Rock" ~ 7
  )
         )

eco_base <- eco_base %>%
  mutate(
    depth_m_ = as.numeric(as.character(depth_m_)),  # Convert depth to numeric
    dfs_m_ = as.numeric(as.character(dfs_m_))  # Convert dfs to numeric
  )

#
eco_base$depth_m_[which(eco_base$depth_m_ > 80)] <- eco_base$depth_m_[which(eco_base$depth_m_ > 80)] / 10



unique(eco_base$depth_m_)
colnames(eco_jit)
```
 [1] "transect"       "point"          "lattitude"      "longitude"      "year"           "potfol"        
 [7] "elonut"         "cerdem"         "najfle"         "potcri"         "myrspi"         "valame"        
[13] "najmin"         "potgra"         "potper"         "zanpal"         "calsp"          "nymodo"        
[19] "lemmin"         "spipol"         "stupec"         "elasp"          "potbic"         "potpus"        
[25] "unidentif3"     "elesp"          "spaspp"         "typha"          "point_sum"      "yearly_sum"    
[31] "potfol_sum"     "elonut_sum"     "cerdem_sum"     "najfle_sum"     "potcri_sum"     "myrspi_sum"    
[37] "valame_sum"     "najmin_sum"     "potgra_sum"     "potper_sum"     "zanpal_sum"     "calsp_sum"     
[43] "nymodo_sum"     "lemmin_sum"     "spipol_sum"     "stupec_sum"     "elasp_sum"      "potbic_sum"    
[49] "potpus_sum"     "unidentif3_sum" "elesp_sum"      "spaspp_sum"     "typha_sum"      "other_sum"     
[55] "substrate"      "dfs_m_"         "depth_m_"       "substrate.code"


```{r}
colnames(eco_jit)
colnames(eco_base)

eco_base %>% 
  summary(year, transect, other_sum, point, yearly_sum, myrspi_sum)
```



Implement Jitter from Jitter testing stage 
```{r}
# "dfs_m_" "depth_m_" "lattitude"  "longitude"

eco_jit <- eco_base[rep(1:nrow(eco_base), each = 5), ]  # Triplicate each row
eco_jit$dfs_m_ <- round(jitter(eco_jit$dfs_m_, amount = 2)) # jitter distance from shore
eco_jit$depth_m_ <- round(jitter(eco_jit$depth_m_, amount = 1)) # jitter depth 

eco_jit <- eco_jit %>%  filter(dfs_m_ > 0 & depth_m_ > 0) # no values that are less than one < 0 

eco_jit <- eco_jit %>% select(transect, point, lattitude, longitude, year, depth_m_, dfs_m_, substrate.code, yearly_sum, cerdem_sum, myrspi_sum, other_sum)

eco_jit # eco_jit variable created  

```





```{r}
colnames(eco_jit)

eco_jit[is.na(eco_jit)] <- 0
eco_jit <- na.omit(eco_jit)



# Suppose we want to fit a single model for each response, 
# but across all data from 2008–2020, with year, depth, dfs, substrate_code
response_vars <- c("cerdem_sum", "myrspi_sum", "other_sum")
brt_models <- list()

for (resp in response_vars) {
  cat("Training GBM model for", resp, "across all years...\n")
  
  # Year as numeric predictor:
  formula_all <- as.formula(
    paste(resp, "~ year + depth_m_ + dfs_m_ + substrate.code")
  )
  
  model <- tryCatch({
    gbm(
      formula = formula_all,
      data = eco_jit,  # includes 2008–2020
      distribution = "gaussian",
      n.trees = 1000,
      interaction.depth = 5,
      shrinkage = 0.01,
      bag.fraction = 0.75,
      cv.folds = 10
    )
  }, error = function(e) {
    cat("Error training model for", resp, ":", e$message, "\n")
    return(NULL)
  })
  
  brt_models[[resp]] <- model
  cat("Finished training model for", resp, "\n")
}

# Check success
successful_models <- names(brt_models)[!sapply(brt_models, is.null)]
cat("Models that trained successfully:\n")
print(successful_models)

```
Synthetic data creation

```{r}


twenty <- eco_base %>%
  filter(year == 2020)

twenty_base <- twenty %>% select(year, transect, point, lattitude, longitude, year, depth_m_, dfs_m_, substrate.code)

twenty_base$year <- 2021 #overide so that year is involved in the calculations


# For each response variable, generate predictions for 2021
responses <- c("cerdem_sum", "myrspi_sum", "other_sum")

for (resp in responses) {
  # Retrieve the trained model for this response
  model <- brt_models[[resp]]
  
  # Generate predictions for 2021 using 'twenty_base'
  # n.trees must match however many trees the model ended with
  preds <- predict(
    model,
    newdata = twenty_base,
    n.trees = model$n.trees
  )
  
  # Store the predictions in a new column, e.g. "pred_cerdem_sum"
  pred_colname <- paste0("pred_", resp)
  twenty_base[[pred_colname]] <- preds
}

# Now 'twenty_base' will have additional columns:
# pred_cerdem_sum, pred_myrspi_sum, pred_other_sum




```

